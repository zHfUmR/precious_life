# 架构优化指南 🏗️

这份指南将帮助你将现有项目升级为更优秀的架构，引入数据库支持，并改善代码组织结构。

## 🎯 优化目标

1. **清晰的数据层架构**：引入Repository模式，统一数据访问
2. **数据库支持**：使用Drift ORM提供类型安全的数据库操作
3. **更好的代码组织**：模块化设计，降低耦合度
4. **缓存策略优化**：多级缓存提高性能
5. **错误处理改进**：统一的异常处理机制

## 📋 当前架构问题分析

### 1. 数据访问混乱
```dart
// ❌ 当前代码：直接在ViewModel中操作存储
class WeatherCardVm extends Notifier<WeatherCardState> {
  Future<void> addFollowedPoint(FollowedPoint point) async {
    // 直接操作SharedPreferences
    final newPointsJson = jsonEncode(pointsToStore);
    await CPSP.instance.setString(StorageKeys.followedWeatherPoints, newPointsJson);
  }
}
```

### 2. 缺少统一的错误处理
```dart
// ❌ 当前代码：错误处理分散且不一致
try {
  final weatherResponse = await QweatherApiService.getNowWeather(point.locationStr);
} catch (e) {
  // 不同地方有不同的错误处理逻辑
}
```

### 3. 没有数据缓存策略
- 每次都需要网络请求
- 没有离线数据支持
- 重复数据获取

## 🚀 新架构设计

### 数据层架构图
```
┌─────────────────┐
│   UI Layer      │ ← Riverpod Providers
│                 │
├─────────────────┤
│ Repository Layer│ ← 统一数据访问接口
│                 │
├─────────────────┤
│ DataSource Layer│ ← 具体数据获取实现
│ ├─ Local        │   ├─ Database (Drift)
│ ├─ Remote       │   ├─ SharedPreferences  
│ └─ Cache        │   └─ API Clients
└─────────────────┘
```

### 存储策略分层
```
内存缓存 (最快)
    ↓
本地数据库 (中等速度，持久化)
    ↓
SharedPreferences (简单配置)
    ↓
远程API (最慢，但数据最新)
```

## 📝 迁移步骤

### 第一步：配置数据库依赖

1. **更新 `pubspec.yaml`**
```yaml
dependencies:
  # 现有依赖保持不变...
  
  # 添加数据库支持
  sqflite: ^2.3.0
  drift: ^2.14.0
  sqlite3_flutter_libs: ^0.5.0
  path_provider: ^2.1.0
  path: ^1.8.3

dev_dependencies:
  # 现有依赖保持不变...
  
  # 添加代码生成
  drift_dev: ^2.14.0
```

2. **运行依赖安装**
```bash
flutter pub get
```

### 第二步：创建Repository层

**优化前的代码**：
```dart
// ❌ 在ViewModel中直接操作存储
class WeatherCardVm extends Notifier<WeatherCardState> {
  Future<void> loadFollowedWeather() async {
    // 直接读取SharedPreferences
    final followedPointsJson = await CPSP.instance.getString(StorageKeys.followedWeatherPoints);
    // 直接调用API
    final weatherResponse = await QweatherApiService.getNowWeather(point.locationStr);
  }
}
```

**优化后的代码**：
```dart
// ✅ 使用Repository统一数据访问
class WeatherCardVm extends Notifier<WeatherCardState> {
  late final WeatherRepository _weatherRepository;
  
  @override
  WeatherCardState build() {
    _weatherRepository = ref.read(weatherRepositoryProvider);
    return const WeatherCardState.initial();
  }
  
  Future<void> loadFollowedWeather() async {
    try {
      // 通过Repository获取数据，自动处理缓存
      final weatherData = await _weatherRepository.getWeatherData(locationStr);
      state = state.copyWith(weatherData: weatherData);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }
}
```

### 第三步：优化现有WeatherCardVm

**创建新的WeatherCardVm**：
```dart
// lib/features/todo/ui/providers/weather_card_vm_v2.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:precious_life/data/repositories/weather_repository.dart';
import 'package:precious_life/data/providers/repository_providers.dart';

@riverpod
class WeatherCardVmV2 extends _$WeatherCardVmV2 {
  late final WeatherRepository _weatherRepository;
  
  @override
  WeatherCardState build() {
    _weatherRepository = ref.read(weatherRepositoryProvider);
    return const WeatherCardState.initial();
  }
  
  /// 加载关注的天气点（带缓存优化）
  Future<void> loadFollowedWeather({bool forceRefresh = false}) async {
    state = state.copyWith(weatherFollowedState: 
      const WeatherCardFollowedState(loadingStatus: LoadingStatus.loading));
    
    try {
      // 从本地存储获取关注点列表
      final followedPoints = await _getFollowedPoints();
      
      if (followedPoints.isEmpty) {
        state = state.copyWith(
          weatherFollowedState: const WeatherCardFollowedState(
            loadingStatus: LoadingStatus.success, 
            followedWeather: []));
        return;
      }
      
      // 使用Repository批量获取天气数据
      final locations = followedPoints.map((p) => p.locationStr).toList();
      final weatherDataMap = await _weatherRepository.getBatchWeatherData(
        locations, 
        maxConcurrency: 3
      );
      
      // 构建结果
      final weatherResults = followedPoints.map((point) {
        final weatherData = weatherDataMap[point.locationStr];
        return WeatherCardFollowedWeather(
          point: point,
          loadingStatus: weatherData != null 
            ? LoadingStatus.success 
            : LoadingStatus.failure,
          weather: weatherData?.now,
          errorMessage: weatherData == null ? '获取天气数据失败' : null,
        );
      }).toList();
      
      state = state.copyWith(
        weatherFollowedState: WeatherCardFollowedState(
          loadingStatus: LoadingStatus.success,
          followedWeather: weatherResults));
          
    } catch (e) {
      state = state.copyWith(
        weatherFollowedState: WeatherCardFollowedState(
          loadingStatus: LoadingStatus.failure,
          errorMessage: e.toString()));
    }
  }
  
  /// 预加载天气数据（后台静默获取）
  Future<void> preloadWeatherData() async {
    try {
      final followedPoints = await _getFollowedPoints();
      final locations = followedPoints.map((p) => p.locationStr).toList();
      await _weatherRepository.preloadWeatherData(locations);
    } catch (e) {
      // 预加载失败不影响主流程
    }
  }
}
```

### 第四步：渐进式迁移

1. **保留现有代码**：暂时保留 `weather_card_vm.dart`
2. **创建新版本**：创建 `weather_card_vm_v2.dart` 使用新架构
3. **A/B测试**：在不同页面使用不同版本
4. **逐步迁移**：确认新版本稳定后替换旧版本

### 第五步：数据库迁移

**当前存储方式**：
```dart
// ❌ 所有数据都存在SharedPreferences中
await CPSP.instance.setString(StorageKeys.followedWeatherPoints, newPointsJson);
```

**优化后的存储策略**：
```dart
// ✅ 根据数据类型选择存储方式
class DataStorageStrategy {
  // 简单配置 → SharedPreferences
  static Future<void> saveApiKey(String key) async {
    await StorageDataSourceFactory.getSettingsStorage().saveString('api_key', key);
  }
  
  // 结构化数据 → SQLite数据库
  static Future<void> saveFollowedPoints(List<FollowedPoint> points) async {
    await database.todoDao.saveFollowedPoints(points);
  }
  
  // 缓存数据 → 内存 + 数据库双重缓存
  static Future<void> cacheWeatherData(String location, WeatherData data) async {
    await weatherRepository.cacheWeatherData(location, data);
  }
}
```

## 🔧 实施建议

### 优先级排序

**高优先级（立即实施）**：
1. ✅ 创建Repository层
2. ✅ 重构WeatherCardVm使用Repository
3. ✅ 优化错误处理

**中优先级（一个月内）**：
4. 完成数据库配置
5. 实现数据迁移工具
6. 添加离线支持

**低优先级（长期优化）**：
7. 添加数据同步机制
8. 实现更复杂的缓存策略
9. 添加性能监控

### 风险控制

1. **渐进式迁移**：不要一次性替换所有代码
2. **保留备份**：保留现有代码作为fallback
3. **充分测试**：每个步骤都要测试功能完整性
4. **性能监控**：关注迁移后的性能变化

## 📊 预期收益

### 代码质量提升
- **可测试性**：Repository层易于mock和测试
- **可维护性**：清晰的分层架构
- **可扩展性**：新增数据源或存储方式容易

### 性能优化
- **缓存策略**：多级缓存减少网络请求
- **批量操作**：减少数据库访问次数
- **离线支持**：提高用户体验

### 开发效率
- **统一接口**：减少重复代码
- **错误处理**：统一的异常管理
- **依赖注入**：便于单元测试和模块化

## 🎉 总结

这个架构优化方案既保持了现有功能的稳定性，又为未来扩展打下了良好基础。通过渐进式迁移，你可以：

1. 🏗️ **建立清晰的数据层架构**
2. 📱 **引入现代化的数据库支持**  
3. ⚡ **优化性能和用户体验**
4. 🔧 **提高代码质量和可维护性**

记住，好的架构不是一蹴而就的，而是在实践中不断优化和完善的结果！(◕‿◕)♡ 